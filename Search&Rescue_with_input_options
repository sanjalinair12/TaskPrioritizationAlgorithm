import numpy as np
import pandas as pd

def get_input_from_excel():
    file_path = input("Enter the path to your Excel file: ")
    try:
        df_criteria_comparison = pd.read_excel(file_path, sheet_name='Criteria Comparison', index_col=0)
        df_robots = pd.read_excel(file_path, sheet_name='Robots')
        df_tasks = pd.read_excel(file_path, sheet_name='Tasks', index_col=0)
        criteria_comparison_matrix = df_criteria_comparison.values
        num_criteria = criteria_comparison_matrix.shape[0]
        criteria = df_criteria_comparison.columns
        robots = []
        for index, row in df_robots.iterrows():
            robots.append({'ID': row['ID'], 'Type': row['Type'], 'Values': row.iloc[2:].values.astype(float)})
        tasks = []
        for index, row in df_tasks.iterrows():
            tasks.append({'Type': index, 'Scores': row.values.astype(float)})
        return num_criteria, criteria, robots, tasks, criteria_comparison_matrix
    except Exception as e:
        print("Error reading Excel file:", str(e))
        return None

def get_input_manually():
    num_criteria = 6
    criteria = ['Navigation Efficiency', 'Payload Capacity', 'Safety', 'Communication Effectiveness', 'Adaptability', 'Energy Efficiency']
    criteria_comparison_matrix = np.zeros((num_criteria, num_criteria))
    
    print("\nEnter AHP Pairwise Comparisons (e.g., 3 or 1/3):")
    for i in range(num_criteria):
        for j in range(i+1, num_criteria):
            while True:
                comparison = input(f"Enter comparison between {criteria[i]} and {criteria[j]}: ")
                try:
                    if '/' in comparison:
                        numerator, denominator = map(float, comparison.split('/'))
                        comparison_value = numerator / denominator
                    else:
                        comparison_value = float(comparison)
                    criteria_comparison_matrix[i, j] = np.round(comparison_value, 4)
                    criteria_comparison_matrix[j, i] = np.round(1 / comparison_value, 4)
                    break
                except ValueError:
                    print("Invalid input. Please enter a number or a fraction (e.g., 3 or 1/3).")
    for i in range(num_criteria):
        criteria_comparison_matrix[i, i] = 1
        
    num_robots = int(input("\nEnter the number of robots: "))
    robots = []
    robot_types = ['Drone', 'Ground Robot', 'Creeper Robot']
    drone_id = 1
    ground_robot_id = 1
    creeper_robot_id = 1
    for i in range(num_robots):
        while True:
            robot_type = input(f"Enter the type of robot {i+1} (Drone, Ground Robot, Creeper Robot): ")
            if robot_type in robot_types:
                break
            print("Invalid robot type. Please enter one of the following: Drone, Ground Robot, Creeper Robot")
        
        while True:
            try:
                values_str = input(f"Enter the values for {robot_type} {i+1} (6 values separated by spaces): ")
                values = [np.round(float(x), 4) for x in values_str.split()]
                if len(values) == num_criteria:
                    break
                print(f"Invalid number of values. Please enter exactly {num_criteria} values.")
            except ValueError:
                print("Invalid input. Values must be numbers.")

        if robot_type == 'Drone':
            robot_id = f"D{drone_id}"
            drone_id += 1
        elif robot_type == 'Ground Robot':
            robot_id = f"G{ground_robot_id}"
            ground_robot_id += 1
        else:
            robot_id = f"C{creeper_robot_id}"
            creeper_robot_id += 1
        robots.append({'ID': robot_id, 'Type': robot_type, 'Values': values, 'Q_Index': 0.0}) # Add Q_Index placeholder

    num_tasks = int(input("\nEnter the number of tasks: "))
    task_types = ['Scan and Rescue', 'Supply Necessities', 'Lifting Remains']
    tasks = []
    for i in range(num_tasks):
        while True:
            task_type = input(f"Enter the type of task {i+1} (Scan and Rescue, Supply Necessities, Lifting Remains): ")
            if task_type in task_types:
                break
            print("Invalid task type. Please enter one of the following: Scan and Rescue, Supply Necessities, Lifting Remains")

        while True:
            try:
                scores_str = input(f"Enter scores for Task {i+1} (6 values separated by spaces on a scale of 1-9): ")
                scores = [np.round(float(x), 4) for x in scores_str.split()]
                if len(scores) == num_criteria:
                    break
                print(f"Invalid number of scores. Please enter exactly {num_criteria} scores.")
            except ValueError:
                print("Invalid input. Scores must be numbers.")
        tasks.append({'Type': task_type, 'Scores': scores})
    
    return num_criteria, criteria, robots, tasks, criteria_comparison_matrix

# Removed get_robot_score function

def main():
    print("Select input method:")
    print("1. Manual input")
    print("2. Load from Excel file")
    choice = input("Enter your choice (1/2): ")
    if choice == '1':
        result = get_input_manually()
        if result:
            num_criteria, criteria, robots, tasks, criteria_comparison_matrix = result
        else:
            return
    elif choice == '2':
        result = get_input_from_excel()
        if result:
            num_criteria, criteria, robots, tasks, criteria_comparison_matrix = result
        else:
            print("Failed to load data from Excel file.")
            return
    else:
        print("Invalid choice.")
        return
    
    # --- AHP: Calculate Criteria Weights ---
    eigenvalues, eigenvectors = np.linalg.eig(criteria_comparison_matrix)
    max_eigenvalue_index = np.argmax(eigenvalues)
    criteria_weights = np.abs(eigenvectors[:, max_eigenvalue_index])
    criteria_weights = criteria_weights / np.sum(criteria_weights)
    
    # --- Task Priority Calculation ---
    task_priorities = {}
    for task in tasks:
        # Note: The original task priority calculation uses the raw scores * criteria_weights
        priority = np.dot(task['Scores'], criteria_weights)
        task_priorities[task['Type']] = priority
        
    sorted_tasks = sorted(task_priorities.items(), key=lambda x: x[1], reverse=True)
    print("\nTask Priorities (Sorted):")
    for task, priority in sorted_tasks:
        print(f"{task}: {priority:.4f}")
    
    # --- TOPSIS/VIKOR: Robot Evaluation and Q Index Calculation ---
    decision_matrix = np.array([robot['Values'] for robot in robots])
    weighted_decision_matrix = decision_matrix * criteria_weights
    
    # TOPSIS Ideal Solutions
    ideal_best = np.max(weighted_decision_matrix, axis=0)
    ideal_worst = np.min(weighted_decision_matrix, axis=0)
    
    # Distances (D+ and D- using L2 norm from TOPSIS)
    D_plus = np.sqrt(np.sum((weighted_decision_matrix - ideal_best) ** 2, axis=1))
    D_minus = np.sqrt(np.sum((weighted_decision_matrix - ideal_worst) ** 2, axis=1))

    D_plus_best = np.min(D_plus)
    D_plus_worst = np.max(D_plus)
    D_minus_best = np.min(D_minus)
    D_minus_worst = np.max(D_minus)

    v = 0.5 # VIKOR strategy weight

    # VIKOR Q Index Calculation
    # Handle division by zero for degenerate cases
    if (D_plus_worst - D_plus_best) == 0 or (D_minus_worst - D_minus_best) == 0:
        # Fallback for degenerate case where max and min are equal
        Q = D_plus 
    else:
        # Normalized D+ and D- to calculate Q
        Q = v * ((D_plus - D_plus_best) / (D_plus_worst - D_plus_best)) + \
            (1-v) * ((D_minus_worst - D_minus) / (D_minus_worst - D_minus_best))

    # Store Q index in robot objects
    for i, robot in enumerate(robots):
        robot['Q_Index'] = Q[i]

    # Rank robots by type based on Q index (ascending Q is better)
    # The key is to sort by 'Q_Index'
    ground_robots = sorted([robot for robot in robots if robot['Type'] == 'Ground Robot'], key=lambda x: x['Q_Index'])
    drone_robots = sorted([robot for robot in robots if robot['Type'] == 'Drone'], key=lambda x: x['Q_Index'])
    creeper_robots = sorted([robot for robot in robots if robot['Type'] == 'Creeper Robot'], key=lambda x: x['Q_Index'])
    
    print("\nRobot Rankings (Best/Lowest Q Index First):")
    all_ranked_robots = sorted(robots, key=lambda x: x['Q_Index'])
    for robot in all_ranked_robots:
        print(f"{robot['ID']} ({robot['Type']}): Q={robot['Q_Index']:.4f}")
    
    # --- Task-Robot Assignment based on VIKOR Q Index ---
    
    print("\n--- Task Assignment ---")
    for task_type, task_priority in sorted_tasks:
        print(f"\n{task_type} Priority: {task_priority:.4f}")
        assigned_robots = []
        
        # Assignment logic selects the top-ranked available robot from the Q-sorted lists
        
        if task_type == 'Scan and Rescue':
            # Needs 1 Drone and 2 Ground Robots
            if drone_robots:
                best_drone = drone_robots.pop(0) # Pop the top-ranked (lowest Q)
                assigned_robots.append(best_drone)
            for _ in range(2):
                if ground_robots:
                    best_ground = ground_robots.pop(0) # Pop the top-ranked (lowest Q)
                    assigned_robots.append(best_ground)

        elif task_type == 'Lifting Remains':
            # Needs 2 Ground Robots
            for _ in range(2):
                if ground_robots:
                    best_ground = ground_robots.pop(0) # Pop the top-ranked (lowest Q)
                    assigned_robots.append(best_ground)

        elif task_type == 'Supply Necessities':
            # Needs 1 Ground Robot and 1 Creeper Robot
            if ground_robots:
                best_ground = ground_robots.pop(0) # Pop the top-ranked (lowest Q)
                assigned_robots.append(best_ground)
            if creeper_robots:
                best_creeper = creeper_robots.pop(0) # Pop the top-ranked (lowest Q)
                assigned_robots.append(best_creeper)

        if assigned_robots:
            print(f"Team for {task_type}:")
            for robot in assigned_robots:
                print(f"{robot['ID']} ({robot['Type']}) [Q={robot['Q_Index']:.4f}]")
        else:
            print(f"Not enough robots available to form a team for {task_type}.")


if __name__ == "__main__":
    main()
